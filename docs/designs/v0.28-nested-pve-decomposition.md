# Design Summary: Nested PVE Playbook Decomposition

**Issues:** iac-driver#49, iac-driver#41
**Author:** Claude
**Date:** 2026-01-17

## Problem Statement

The nested-pve scenario currently runs `nested-pve-setup.yml` as a single monolithic operation. This creates two problems:

1. **All-or-nothing execution**: Cannot run network setup independently from repo sync
2. **No recovery path**: If repo sync fails, network setup must be re-run
3. **Context-dependent destruction**: Destructor requires context file with VM IDs from constructor

**Success Criteria:**
- Scenario phases can target specific task subsets (network, ssh, repos)
- Destructor can discover and destroy VMs without context file
- Existing `--context-file` behavior preserved for backward compatibility

## Proposed Solution

**Summary:** Decompose nested-pve-setup.yml into focused playbooks and add VM auto-discovery for the destructor.

### Part 1: Playbook Decomposition (iac-driver#49)

**Current structure:**
```
ansible/playbooks/nested-pve-setup.yml
    └── roles/nested-pve/tasks/main.yml
            ├── include: network.yml    (8 tasks)
            ├── include: ssh-keys.yml   (3 tasks)
            └── include: copy-files.yml (30+ tasks)
```

**Proposed structure:**
```
ansible/playbooks/
├── nested-pve-network.yml    # Network bridge setup
├── nested-pve-ssh.yml        # SSH key copy
├── nested-pve-repos.yml      # Repo sync, PVE config, token/key injection
└── nested-pve-setup.yml      # Orchestration (calls all three)
```

### Part 2: VM Auto-Discovery (iac-driver#41)

**Current destructor flow:**
```
context.json → NestedPVEDestructor → destroy(vm_id=99913)
```

**Proposed destructor flow:**
```
PVE API → DiscoverVMsAction(pattern="nested-pve*") → destroy(discovered_vms)
         ↓ fallback
context.json → destroy(vm_id from context)
```

## Detailed Design

### New Playbooks

**nested-pve-network.yml:**
```yaml
- name: Configure nested PVE networking
  hosts: all
  gather_facts: true
  become: true
  tasks:
    - name: Include network setup tasks
      ansible.builtin.include_role:
        name: nested-pve
        tasks_from: network.yml
```

**nested-pve-ssh.yml:**
```yaml
- name: Copy SSH keys for nested access
  hosts: all
  gather_facts: false
  become: true
  tasks:
    - name: Include SSH key copy tasks
      ansible.builtin.include_role:
        name: nested-pve
        tasks_from: ssh-keys.yml
```

**nested-pve-repos.yml:**
```yaml
- name: Sync repos and configure PVE for IaC
  hosts: all
  gather_facts: true
  become: true
  tasks:
    - name: Include file copy and PVE config tasks
      ansible.builtin.include_role:
        name: nested-pve
        tasks_from: copy-files.yml
```

### New Actions

**DiscoverVMsAction:**
```python
class DiscoverVMsAction(Action):
    """Discover VMs matching a pattern via PVE API."""

    def __init__(
        self,
        name: str,
        pve_host_attr: str = 'ssh_host',
        name_pattern: str = 'nested-pve*',
        vmid_range: tuple[int, int] | None = (99900, 99999),
    ):
        self.name = name
        self.pve_host_attr = pve_host_attr
        self.name_pattern = name_pattern
        self.vmid_range = vmid_range

    def run(self, config, context) -> ActionResult:
        """Query PVE API and filter by pattern/range."""
        host = context.get(self.pve_host_attr) or getattr(config, self.pve_host_attr)

        # Query PVE cluster resources
        cmd = "pvesh get /cluster/resources --type vm --output-format json"
        result = run_ssh(host, 'root', cmd)

        vms = json.loads(result.stdout)
        discovered = []

        for vm in vms:
            # Filter by name pattern (fnmatch)
            if not fnmatch.fnmatch(vm['name'], self.name_pattern):
                continue

            # Filter by vmid range
            if self.vmid_range:
                if not (self.vmid_range[0] <= vm['vmid'] <= self.vmid_range[1]):
                    continue

            discovered.append({
                'vmid': vm['vmid'],
                'name': vm['name'],
                'status': vm['status'],
                'node': vm['node'],
            })

        context['discovered_vms'] = discovered
        return ActionResult(
            success=True,
            message=f"Discovered {len(discovered)} VMs matching '{self.name_pattern}'"
        )
```

**DestroyDiscoveredVMsAction:**
```python
class DestroyDiscoveredVMsAction(Action):
    """Destroy all VMs in context['discovered_vms']."""

    def __init__(
        self,
        name: str,
        pve_host_attr: str = 'ssh_host',
        context_key: str = 'discovered_vms',
        force_stop: bool = True,
    ):
        self.name = name
        self.pve_host_attr = pve_host_attr
        self.context_key = context_key
        self.force_stop = force_stop

    def run(self, config, context) -> ActionResult:
        """Stop and destroy each discovered VM."""
        vms = context.get(self.context_key, [])
        if not vms:
            return ActionResult(success=True, message="No VMs to destroy")

        host = context.get(self.pve_host_attr) or getattr(config, self.pve_host_attr)
        destroyed = []

        for vm in vms:
            vmid = vm['vmid']

            # Stop if running
            if vm.get('status') == 'running' and self.force_stop:
                run_ssh(host, 'root', f"qm stop {vmid} --timeout 30")

            # Destroy
            run_ssh(host, 'root', f"qm destroy {vmid} --purge")
            destroyed.append(vmid)

        return ActionResult(
            success=True,
            message=f"Destroyed {len(destroyed)} VMs: {destroyed}"
        )
```

### Updated Scenario Phases

**NestedPVEConstructor phases (after):**
```python
phases = [
    # ... existing phases through install_pve ...

    ('setup_network', AnsiblePlaybookAction(
        name='configure-network',
        playbook='playbooks/nested-pve-network.yml',
        inventory='inventory/remote-dev.yml',
        host_key='inner_ip',
        extra_vars={'ansible_user': 'root'},
    ), 'Configure inner PVE networking'),

    ('setup_ssh', AnsiblePlaybookAction(
        name='copy-ssh-keys',
        playbook='playbooks/nested-pve-ssh.yml',
        inventory='inventory/remote-dev.yml',
        host_key='inner_ip',
        extra_vars={'ansible_user': 'root'},
    ), 'Copy SSH keys for nested access'),

    ('setup_repos', AnsiblePlaybookAction(
        name='sync-repos-config',
        playbook='playbooks/nested-pve-repos.yml',
        inventory='inventory/remote-dev.yml',
        host_key='inner_ip',
        extra_vars={
            'ansible_user': 'root',
            'bootstrap_use_local': True,
            'homestak_src_dir': str(Path.cwd().parent),
        },
    ), 'Sync repos and configure PVE'),

    # ... remaining phases ...
]
```

**NestedPVEDestructor phases (after):**
```python
phases = [
    ('discover', DiscoverVMsAction(
        name='discover-nested-vms',
        pve_host_attr='ssh_host',
        name_pattern='nested-pve*',
        vmid_range=(99900, 99999),
    ), 'Discover nested PVE VMs'),

    ('cleanup_inner', CleanupInnerVMsAction(
        name='cleanup-inner-vms',
        pve_host_attr='inner_ip',  # Falls back to context
    ), 'Cleanup VMs on inner PVE'),

    ('destroy', DestroyDiscoveredVMsAction(
        name='destroy-nested-vms',
        pve_host_attr='ssh_host',
        context_key='discovered_vms',
    ), 'Destroy discovered VMs'),
]
```

## Alternatives Considered

### Option A: Decompose as-is (Recommended)
Split into 3 playbooks using `tasks_from` directive.

| Pros | Cons |
|------|------|
| Minimal changes | copy-files.yml remains large |
| Uses existing ansible patterns | PVE-specific tasks not reusable |
| Low risk | |

### Option B: Extract PVE-specific setup to collection role
Move snippets content type, SSL cert regen, and API token to `homestak.proxmox.configure`.

| Pros | Cons |
|------|------|
| Reuses existing api_token role | Adds coordination complexity |
| PVE tasks become reusable | Token capture still needed in nested-pve |
| Cleaner separation | SSL workaround is nested-specific |

**Analysis:** copy-files.yml already handles API token inline (duplicating `homestak.proxmox.api_token`). The PVE-specific tasks (snippets, SSL) are only ~15 lines and specific to nested/fresh PVE instances. Extraction adds complexity without clear reuse benefit.

### Option C: Wait for bootstrap --source flag (v0.30)
Use bootstrap's planned `--source` flag to sync from local repos.

| Pros | Cons |
|------|------|
| Unified approach | Blocks on v0.30 |
| Bootstrap handles dependencies | Still need site-config/secrets sync |
| | Still need token/key injection |

**Analysis:** Even with `--source`, bootstrap cannot handle secrets sync or nested-PVE-specific configuration. This option doesn't eliminate the need for copy-files.yml.

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Playbook split breaks existing workflows | Low | Medium | Test full roundtrip after changes |
| Discovery pattern too broad | Low | High | Use vmid_range filter + name pattern |
| Discovery misses VMs | Medium | Medium | Fall back to context file if available |

## Test Plan

**Scenario:** nested-pve-roundtrip on father

**Steps:**
1. Run constructor: `./run.sh --scenario nested-pve-constructor --host father -v`
2. Verify phases run independently (check audit log for 3 setup phases)
3. Run destructor without context: `./run.sh --scenario nested-pve-destructor --host father -v`
4. Verify discovery finds and destroys the nested-pve VM
5. Run full roundtrip: `./run.sh --scenario nested-pve-roundtrip --host father -v`

**Expected result:**
- Constructor creates nested PVE with separated setup phases
- Destructor discovers and destroys VMs without needing context file
- Full roundtrip completes successfully

## Implementation Order

1. **ansible repo:**
   - Create `nested-pve-network.yml` playbook
   - Create `nested-pve-ssh.yml` playbook
   - Create `nested-pve-repos.yml` playbook
   - Update `nested-pve-setup.yml` to call all three (backward compat)

2. **iac-driver repo:**
   - Add `DiscoverVMsAction` to `src/actions/proxmox.py`
   - Add `DestroyDiscoveredVMsAction` to `src/actions/proxmox.py`
   - Update `NestedPVEConstructor` phases in `nested_pve.py`
   - Update `NestedPVEDestructor` phases in `cleanup_nested_pve.py`

3. **Testing:**
   - Run nested-pve-roundtrip to validate
   - Test destructor without context file
